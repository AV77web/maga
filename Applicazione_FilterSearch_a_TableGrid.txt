puoi fare in modo che i filtri selezionati nel componente FilterSerarch vengono applicati alla tabella TableGrid sulla base del codice attuale?


Gemini
Certamente! Per fare in modo che i filtri selezionati nel componente FilterSearch vengano applicati alla tabella TableGrid, dobbiamo modificare il componente MovimentiForm.jsx per utilizzare correttamente i risultati forniti da FilterSearch e aggiornare FilterSearch.jsx per includere tutti i dati necessari.

Ecco le modifiche proposte:

1. Aggiornamento di FilterSearch.jsx
Il componente FilterSearch costruisce una query SQL. Dobbiamo assicurarci che questa query selezioni anche la descrizione dell'articolo (descriptionart), poiché è richiesta da TableGrid nel componente MovimentiForm.

FilterSearch.jsx
-0
+1
      SELECT 
        m.id,
        m.quantita,
        a.name AS descriptionart,
        c.description AS descriptioncau,
        m.tipo,
        m.idart,

2. Aggiornamento di MovimentiForm.jsx
In MovimentiForm.jsx, apporteremo le seguenti modifiche:

Rimuoveremo lo stato filterValues e la funzione handleFilterSearch, poiché FilterSearch gestirà internamente i suoi filtri e l'esecuzione della ricerca.
Creeremo una nuova funzione handleFilterResults che riceverà i dati da FilterSearch.
Questa funzione aggiornerà lo stato movimenti con i risultati filtrati, assicurandosi che il formato dei dati (specialmente le date) sia consistente.
Modificheremo l'invocazione del componente <FilterSearch /> per passare handleFilterResults alla prop onResults e rimuoveremo le props non utilizzate.
Rimuoveremo l'import di axios se non utilizzato altrove e la funzione buildQuery commentata.
MovimentiForm.jsx
-72
+49
import MovimentiDialogCustom from "./MovimentiDialogCustom";
import movimentiApi from "../api/movimentiApi"; // API per le operazioni sui movimenti
import ricambiApi from "../api/ricambiApi"; // API per gli articoli/ricambi
import causaliApi from "../api/causaliApi"; // API per le causali
import axios from "axios"; // Per caricare le causali (temporaneo, idealmente via API dedicata)
import causaliApi from "../api/causaliApi"; // API per le causali
import Header from "./Header"; // Aggiunto import per Header

const rowsPerPageOptions = [5, 10, 20, 50];
  const [sortKey, setSortKey] = useState("data");
  const [sortOrder, setSortOrder] = useState("desc");
  const [loadingTable, setLoadingTable] = useState(false);
  const [message, setMessage] = useState("");
  const [filterValues, setFilterValues] = useState({});
  
  const [loadingArticoli, setLoadingArticoli] = useState(false);
  const [loadingCausali, setLoadingCausali] = useState(false);
  const [isSubmitting, setIsSubmitting] = useState(false);

  const toggleSearchPanel = () => {
    setShowSearch((prev) => !prev);
  };

// costruisce dinamicamente la query in base ai filtri
/*const buildQuery = () => {
  let base = `SELECT 
  m.id, m.date, m.quantita , a.name as descriptionart, c.description as descriptioncau, m.tipo , m.note 
  FROM movimenti m 
  JOIN articoli a ON m.idart= a.id 
  JOIN causali c ON m.idcau= c.id
  `;
  if (filterValues.idart) {
    base += `AND m.idart = ${filterValues.idart}`;
  }
  if (filterValues.idcau) {
    base += `AND m.idcau = ${filterValues.idcau}`;
  }
  if (filterValues.tipo) {
    base += `AND m.tipo = ${filterValues.tipo}`;
  }
  if (filterValues.dataDa) {
    base += `AND m.date >=  ${filterValues.dataDa}`;
  }
  if (filterValues.dataA) {
    base += `AND m.date <= ${filterValues.dataA}`;
  }
  }*/

  const handleFilterSearch = async () => {
  // Funzione per gestire i risultati provenienti da FilterSearch
  const handleFilterResults = (resultsFromSearch) => {
    setLoadingTable(true);
    setMessage("");
    setMessage(""); // Pulisce i messaggi precedenti
    try {
      const query = {};
      if (filterValues.idart) query.idart = filterValues.idart;
      if (filterValues.idcau) query.idcau = filterValues.idcau;
      if (filterValues.tipo) query.tipo = filterValues.tipo;
      if (filterValues.dataDa) query.dataDa = filterValues.dataDa;
      if (filterValues.dataA) query.dataA = filterValues.dataA;

      const res = await movimentiApi.fetchByFilters(query);
      if (res.success && Array.isArray(res.data)) {
      if (Array.isArray(resultsFromSearch)) {
        const formattedResults = resultsFromSearch.map((m) => ({
          ...m,
          data: m.data ? new Date(m.data).toISOString().slice(0, 10) : "",
          // descriptionart dovrebbe essere già fornito da FilterSearch grazie alla modifica della query
        }));
        setMovimenti(formattedResults);
        if (formattedResults.length === 0) {
          setMessage("ℹ️ Nessun movimento trovato con i filtri specificati.");
        }
      } else {
        throw new Error("I risultati della ricerca non sono validi.");
      }
    } catch (err) {
      console.error("Errore nell'elaborazione dei risultati del filtro:", err);
      setMessage(`❌ Errore nell'elaborazione dei risultati: ${err.message || err}`);
      setMovimenti([]); // Pulisce la tabella in caso di errore
    } finally {
      setLoadingTable(false);
      setPage(0); // Resetta la paginazione
    }
  };

  /* const handleFilterSearch = async () => {
    setLoadingTable(true);
    setMessage("");
    try {
      const query = {};
      // ... logica precedente basata su filterValues ...
      // const res = await movimentiApi.fetchByFilters(query);
      // ...
    } catch (err) {
      // ...
    } finally {
      setLoadingTable(false);
    }
  }; */

  const fetchMovimenti = useCallback(async () => {
    setLoadingTable(true);
    setMessage("");
    try {
      const res = await movimentiApi.fetchAll();
      if (res.success && Array.isArray(res.data)) {
        setMovimenti(
        res.data.map((m) => ({
          ...m,
            : "",
        }))
      );
    } else {
      throw new Error(res.error || "Dati filtrati non validi.");
    }
  } catch (err) {
    console.error("Errore nei filtri:", err);
    setMessage(`❌ Errore nella ricerca: ${err.message || err}`);
    setMovimenti([]);
  } finally {
    setLoadingTable(false);
  }
};

  const fetchMovimenti = useCallback(async () => {
    setLoadingTable(true);
    setMessage("");
    try {
      const res = await movimentiApi.fetchAll();
      if (res.success && Array.isArray(res.data)) {
        setMovimenti(
          res.data.map((m) => ({
            ...m,
            // Assicurati che la data sia in formato YYYY-MM-DD per l'input e la visualizzazione semplice
            data: m.data
              ? new Date(m.data).toISOString().slice(0, 10)
              : "",
          }))
        );
      } else {
        console.warn("Risposta non valida per i movimenti:", res);
        throw new Error(res.error || "Dati movimenti non validi.");
      { showSearch && 
        (
        <FilterSearch
          onSearch={handleFilterSearch}
          articoli={articoliList}
          causali={causaliList}
          values={filterValues}
          onChange={setFilterValues}
+          onResults={handleFilterResults}
         ></FilterSearch>
         )}
 
Spiegazione delle modifiche a MovimentiForm.jsx:

Rimozione di filterValues e handleFilterSearch:
Lo stato filterValues e la funzione handleFilterSearch non sono più necessari perché FilterSearch ora gestisce autonomamente la logica di filtro e l'invio della query.
Introduzione di handleFilterResults:
Questa nuova funzione viene passata come prop onResults a FilterSearch.
Quando FilterSearch completa una ricerca (con successo o con errore, nel qual caso invia un array vuoto), chiama onResults con i dati ottenuti.
handleFilterResults si occupa di:
Impostare lo stato di caricamento (setLoadingTable).
Formattare i dati ricevuti (in particolare, le date nel formato YYYY-MM-DD).
Aggiornare lo stato movimenti con i risultati, che farà ri-renderizzare TableGrid.
Impostare un messaggio informativo (es. "Nessun movimento trovato").
Resettare la paginazione alla prima pagina.
Modifica dell'invocazione di <FilterSearch />:
Ora passiamo solo la prop onResults={handleFilterResults}. Le props onSearch, articoli, causali, values, e onChange sono state rimosse perché FilterSearch non le utilizza o gestisce tali aspetti internamente.
Formattazione dei dati:
È cruciale che handleFilterResults formatti i dati (specialmente data) nello stesso modo in cui lo fa fetchMovimenti, per garantire coerenza nella visualizzazione e nell'elaborazione successiva.
La modifica in FilterSearch.jsx per includere descriptionart assicura che questo campo sia disponibile per TableGrid.
Rimozione codice non utilizzato:
L'import di axios e la funzione buildQuery commentata sono stati rimossi per pulizia del codice, assumendo che non siano utilizzati altrove.
Con queste modifiche, quando l'utente utilizzerà i filtri in FilterSearch e premerà "Cerca":

FilterSearch costruirà ed eseguirà la query SQL.
Chiamerà la funzione handleFilterResults (passata tramite onResults) con i dati risultanti.
MovimentiForm aggiornerà lo stato movimenti.
TableGrid mostrerà i movimenti filtrati.
Se FilterSearch non trova risultati o incontra un errore nella sua chiamata API, chiamerà onResults([]). handleFilterResults imposterà quindi movimenti a un array vuoto e visualizzerà un messaggio appropriato. FilterSearch stesso potrebbe anche visualizzare un messaggio di errore specifico relativo alla sua operazione di ricerca.

Context Sources (2)

User
modifica FilterSearch in modo che possa essere usato in tutti i componenti CausaliManager4.jsx RicambiManager4.jsx e MovimentiForm,jsx


Gemini
Certamente! Per rendere FilterSearch riutilizzabile e applicare i filtri alla tabella in MovimentiForm, dobbiamo modificare entrambi i componenti.

FilterSearch diventerà un componente più generico che si limita a raccogliere i valori dei filtri definiti esternamente e a chiamare una funzione di ricerca fornita dal componente padre. Il componente padre (MovimentiForm in questo caso) sarà responsabile di definire quali filtri mostrare e come eseguire la ricerca effettiva (chiamando l'API corretta con i parametri giusti).

Ecco le modifiche:

1. Modifica di FilterSearch.jsx
Rendiamo FilterSearch generico: accetterà una lista di campi (fields) da mostrare come filtri e una funzione onSearch da chiamare quando si preme il pulsante "Cerca".

FilterSearch.jsx
-91
+58
//=====================================================
// Componente che esegue una query di ricerca da inviare
// alle api di front end (movimentiApi.js, ricambiApi.js, 
// causaliApi.js).
// Componente generico per la raccolta dei filtri di ricerca.
// Riceve la definizione dei campi di filtro e una funzione
// da chiamare per eseguire la ricerca.
// @author: "villari.andrea@libero.it"
// @version: "1.0.3 2025-06-15"
// @version: "1.1.0 2025-06-16" // Aggiornata versione
//=====================================================

import React, { useState } from "react";
import movimentiApi from "../api/movimentiApi";
import React, { useState, useEffect } from "react";

function FilterSearch({ onResults }) {
function FilterSearch({ fields, onSearch, onResults }) {
  const [filters, setFilters] = useState({
    idart: "",
    idcau: "",
  });

  const [error, setError] = useState("");
  const [loading, setLoading] = useState(false);

  function buildQueryFromFilters() {
    let baseQuery = `
      SELECT 
        m.id,
        m.quantita,
        c.description AS descriptioncau,
        m.tipo,
        m.idart,
        m.idcau,
        m.note,
        m.data
      FROM movimenti m
      JOIN articoli a ON m.idart = a.id 
      JOIN causali c ON m.idcau = c.id
    `;

    const conditions = [];

    const idartValue = parseInt(filters.idart);
    if (!isNaN(idartValue)) {
      conditions.push(`m.idart = ${idartValue}`);
    }

    const idcauValue = parseInt(filters.idcau);
    if (!isNaN(idcauValue)) {
      conditions.push(`m.idcau = ${idcauValue}`);
    }

    if (filters.tipo) {
      conditions.push(`m.tipo = '${filters.tipo}'`);
    }

    if (filters.fromDate) {
      conditions.push(`m.data >= '${filters.fromDate}'`);
    }

    if (filters.toDate) {
      conditions.push(`m.data <= '${filters.toDate}'`);
    }

    const whereClause = conditions.length ? `WHERE ${conditions.join(" AND ")}` : "";
    const orderClause = `ORDER BY m.data DESC`;

    return `${baseQuery} ${whereClause} ${orderClause};`;
  }
  // Initialize filter state based on the provided fields
  useEffect(() => {
    const initialFilters = {};
    fields.forEach(field => {
      initialFilters[field.name] = field.initialValue || '';
    });
    setFilters(initialFilters);
  }, [fields]); // Re-initialize if fields definition changes

  const handleSearch = async () => {
    const query = buildQueryFromFilters();
    console.log("Query generata:", query);
    setLoading(true);
    setError("");
    try {
      const res = await movimentiApi.fetchCustomQuery(query);
      const data = res.data || [];
      setError("");
      if (onResults) onResults(data);
      // Call the search function provided by the parent component
      // The parent is responsible for calling the correct API and handling the query/request logic
      const results = await onSearch(filters);

      if (onResults) {
        onResults(results || []); // Pass results (or empty array) to the parent
      }
    } catch (err) {
      setError(err.message || "Errore nella ricerca.");
      if (onResults) onResults([]);

  return (
    <div style={{ padding: "1rem", background: "#f9f9f9", borderRadius: "8px" }}>
      <h3>Filtro Movimenti</h3>
      <div style={{ display: "flex", gap: "0.5rem", flexWrap: "wrap" }}>
        <input
          type="text"
          placeholder="ID Articolo"
          value={filters.idart}
          onChange={(e) => setFilters({ ...filters, idart: e.target.value })}
        />
        <input
          type="text"
          placeholder="ID Causale"
          value={filters.idcau}
          onChange={(e) => setFilters({ ...filters, idcau: e.target.value })}
        />
        <select
          value={filters.tipo}
          onChange={(e) => setFilters({ ...filters, tipo: e.target.value })}
        >
          <option value="">Tipo</option>
          <option value="C">Carico</option>
          <option value="S">Scarico</option>
        </select>
        <input
          type="date"
          value={filters.fromDate}
          onChange={(e) => setFilters({ ...filters, fromDate: e.target.value })}
        />
        <input
          type="date"
          value={filters.toDate}
          onChange={(e) => setFilters({ ...filters, toDate: e.target.value })}
        />
        <button onClick={handleSearch}>Cerca</button>
      <h3>Filtro Ricerca</h3>
      <div style={{ display: "flex", gap: "0.5rem", flexWrap: "wrap", alignItems: "flex-end" }}>
        {fields.map(field => (
          <div key={field.name} style={{ display: 'flex', flexDirection: 'column', minWidth: '120px' }}>
            {field.label && <label htmlFor={field.name} style={{ fontSize: '0.8rem', marginBottom: '0.2rem' }}>{field.label}</label>}
            {field.type === 'select' ? (
              <select
                id={field.name}
                name={field.name}
                value={filters[field.name] || ''}
                onChange={(e) => setFilters({ ...filters, [field.name]: e.target.value })}
                disabled={loading || field.disabled}
              >
                <option value="">{field.placeholder || `Seleziona ${field.label || field.name}`}</option>
                {(field.options || []).map(option => (
                  <option key={option.value} value={option.value}>
                    {option.label}
                  </option>
                ))}
              </select>
            ) : (
              <input
                id={field.name}
                type={field.type || 'text'}
                name={field.name}
                placeholder={field.placeholder || field.label || field.name}
                value={filters[field.name] || ''}
                onChange={(e) => setFilters({ ...filters, [field.name]: e.target.value })}
                disabled={loading || field.disabled}
              />
            )}
          </div>
        ))}
        <button onClick={handleSearch} disabled={loading}>Cerca</button>
      </div>

      {error && <p style={{ color: "red", marginTop: "1rem" }}>{error}</p>}

Spiegazione delle modifiche a FilterSearch.jsx:

Rimozione Logica Specifica Movimenti: La funzione buildQueryFromFilters e la chiamata a movimentiApi.fetchCustomQuery sono state rimosse.
Props fields e onSearch: Il componente ora accetta fields (un array che descrive i campi di input desiderati) e onSearch (la funzione che verrà chiamata per eseguire la ricerca).
Stato Generico filters: Lo stato filters è ora inizializzato dinamicamente in base ai fields passati.
Rendering Dinamico: Il JSX genera i campi di input (input di testo, data, select) iterando sull'array fields.
handleSearch Aggiornato: Questa funzione ora semplicemente chiama props.onSearch(filters) con i valori correnti dello stato filters. Gestisce lo stato di caricamento (loading) e gli errori, passando i risultati (o un array vuoto in caso di errore) a props.onResults.
useEffect per Inizializzazione: Un useEffect inizializza lo stato filters quando il componente viene montato o quando la definizione dei fields cambia.
2. Modifica di MovimentiForm.jsx
Adattiamo MovimentiForm per utilizzare il nuovo FilterSearch:

Definiremo l'array movimentiFilterFields che specifica i campi di filtro per i movimenti.
Creeremo la funzione handleSearchMovimenti che riceverà i valori dei filtri da FilterSearch, costruirà l'oggetto query per movimentiApi.fetchByFilters e chiamerà l'API.
Passeremo movimentiFilterFields e handleSearchMovimenti come props al componente <FilterSearch>.
La funzione handleFilterResults (che rinominiamo per chiarezza) rimarrà responsabile di aggiornare lo stato movimenti con i dati ricevuti.
MovimentiForm.jsx
-42
+43
import MovimentiDialogCustom from "./MovimentiDialogCustom";
import movimentiApi from "../api/movimentiApi"; // API per le operazioni sui movimenti
import ricambiApi from "../api/ricambiApi"; // API per gli articoli/ricambi
import causaliApi from "../api/causaliApi"; // API per le causali
import axios from "axios"; // Per caricare le causali (temporaneo, idealmente via API dedicata)
import Header from "./Header"; // Aggiunto import per Header

  const [sortKey, setSortKey] = useState("data");
  const [sortOrder, setSortOrder] = useState("desc");
  const [loadingTable, setLoadingTable] = useState(false);
  const [message, setMessage] = useState("");
  const [filterValues, setFilterValues] = useState({});
  
  const [loadingArticoli, setLoadingArticoli] = useState(false);
  const [loadingCausali, setLoadingCausali] = useState(false);
    setShowSearch((prev) => !prev);
  };

// costruisce dinamicamente la query in base ai filtri
/*const buildQuery = () => {
  let base = `SELECT 
  m.id, m.date, m.quantita , a.name as descriptionart, c.description as descriptioncau, m.tipo , m.note 
  FROM movimenti m 
  JOIN articoli a ON m.idart= a.id 
  JOIN causali c ON m.idcau= c.id
  `;
  if (filterValues.idart) {
    base += `AND m.idart = ${filterValues.idart}`;
  }
  if (filterValues.idcau) {
    base += `AND m.idcau = ${filterValues.idcau}`;
  }
  if (filterValues.tipo) {
    base += `AND m.tipo = ${filterValues.tipo}`;
  }
  if (filterValues.dataDa) {
    base += `AND m.date >=  ${filterValues.dataDa}`;
  }
  if (filterValues.dataA) {
    base += `AND m.date <= ${filterValues.dataA}`;
  }
  }*/

  const handleFilterSearch = async () => {
    setLoadingTable(true);
    setMessage("");
  // Define filter fields for Movimenti
  const movimentiFilterFields = useMemo(() => [
    { name: "idart", label: "Articolo", type: "select", options: articoliList.map(art => ({ value: art.id, label: `${art.name} (ID: ${art.id})` })), placeholder: "-- Seleziona Articolo --" },
    { name: "idcau", label: "Causale", type: "select", options: causaliList.map(cau => ({ value: cau.id, label: `${cau.codice} - ${cau.description} (ID: ${cau.id})` })), placeholder: "-- Seleziona Causale --" },
    { name: "tipo", label: "Tipo", type: "select", options: [{ value: "C", label: "Carico" }, { value: "S", label: "Scarico" }], placeholder: "-- Seleziona Tipo --" },
    { name: "dataDa", label: "Data Da", type: "date" },
    { name: "dataA", label: "Data A", type: "date" },
  ], [articoliList, causaliList]); // Dipendenze per rigenerare se liste cambiano

  // Function to handle the search triggered by FilterSearch
  // This function receives the filter values collected by FilterSearch
  const handleSearchMovimenti = async (filterValues) => {
    try {
      const query = {};
      if (filterValues.idart) query.idart = filterValues.idart;
      if (filterValues.idcau) query.idcau = filterValues.idcau;
      if (filterValues.tipo) query.tipo = filterValues.tipo;
      if (filterValues.dataDa) query.dataDa = filterValues.dataDa;
      if (filterValues.dataA) query.dataA = filterValues.dataA;
      if (filterValues.dataDa) query.dataDa = filterValues.dataDa; // Assumi che l'API gestisca il formato data
      if (filterValues.dataA) query.dataA = filterValues.dataA;   // Assumi che l'API gestisca il formato data

      const res = await movimentiApi.fetchByFilters(query);
      if (res.success && Array.isArray(res.data)) {
        setMovimenti(
        res.data.map((m) => ({
        // Return the raw data array. The onResults handler will format it.
        // Ensure descriptionart is included in the data returned by the API
        // (This requires backend modification or joining in the API query if not already done)
        return res.data.map((m) => ({
          ...m,
          data: m.data
            ? new Date(m.data).toISOString().slice(0, 10)
            : "",
        }))
      );
    } else {
    }
  } catch (err) {
    console.error("Errore nei filtri:", err);
    setMessage(`❌ Errore nella ricerca: ${err.message || err}`);
    setMovimenti([]);
    // Throw the error so FilterSearch can catch and display it
    throw new Error(`Errore nella ricerca: ${err.message || err}`);
  }
  // Note: setLoadingTable and setMessage are handled by handleFilterResults now
};

  // Function to handle the results received from FilterSearch
  const handleFilterResults = (resultsFromSearch) => {
    setLoadingTable(true); // Potrebbe essere già true da FilterSearch, ma meglio assicurarsi
    setMessage(""); // Pulisce i messaggi precedenti
    try {
      if (Array.isArray(resultsFromSearch)) {
        setMovimenti(resultsFromSearch); // I dati sono già formattati in handleSearchMovimenti
        if (resultsFromSearch.length === 0) {
          setMessage("ℹ️ Nessun movimento trovato con i filtri specificati.");
        }
      } else {
        throw new Error("I risultati della ricerca non sono validi.");
      }
    } catch (err) {
      console.error("Errore nell'elaborazione dei risultati del filtro:", err);
      setMessage(`❌ Errore nell'elaborazione dei risultati: ${err.message || err}`);
      setMovimenti([]); // Pulisce la tabella in caso di errore
  } finally {
    setLoadingTable(false);
  }
      { showSearch && 
        (
        <FilterSearch
          onSearch={handleFilterSearch}
          articoli={articoliList}
          causali={causaliList}
          values={filterValues}
          onChange={setFilterValues}
          fields={movimentiFilterFields} // Pass the defined fields
+          onSearch={handleSearchMovimenti} // Pass the search handler function
         ></FilterSearch>
         )}
 

Spiegazione delle modifiche a MovimentiForm.jsx:

Rimozione Stato e Handler Vecchi: Lo stato filterValues e la funzione handleFilterSearch sono stati rimossi.
Definizione movimentiFilterFields: È stato creato un array movimentiFilterFields (usando useMemo per ottimizzazione) che descrive i campi di input necessari per filtrare i movimenti. Questo include il name (che corrisponde al nome del parametro atteso dall'API fetchByFilters), la label, il type e, per i select, l'array di options (mappando articoliList e causaliList).
Creazione handleSearchMovimenti: Questa nuova funzione prende l'oggetto filterValues fornito da FilterSearch. Costruisce l'oggetto query nel formato atteso da movimentiApi.fetchByFilters e chiama l'API. Restituisce l'array di dati risultante. La formattazione della data YYYY-MM-DD viene fatta qui prima di restituire i dati. Se l'API fallisce, lancia un errore che FilterSearch catturerà.
Aggiornamento handleFilterResults: Questa funzione ora riceve i dati già formattati da handleSearchMovimenti (tramite FilterSearch che la chiama con i risultati) e si limita ad aggiornare lo stato movimenti e i messaggi.
Utilizzo di FilterSearch: Il componente <FilterSearch> viene ora invocato passando l'array movimentiFilterFields alla prop fields e la funzione handleSearchMovimenti alla prop onSearch. La prop onResults punta ancora a handleFilterResults.
Passi Successivi per gli altri componenti (CausaliManager4, RicambiManager4):

Per utilizzare il nuovo FilterSearch in CausaliManager4 e RicambiManager4, dovrai:

Aggiungere uno stato per controllare la visibilità del pannello di ricerca (showSearch).
Definire un array di causaliFilterFields o ricambiFilterFields simile a quanto fatto per i movimenti, specificando i campi rilevanti per quelle entità (es. codice, description, tipo per causali; codice, name, giacenza per ricambi).
Implementare una funzione handleSearchCausali o handleSearchRicambi che prenda i filterValues, chiami l'API appropriata (es. causaliApi.fetchByFilters, ricambiApi.fetchByFilters - queste funzioni API potrebbero dover essere aggiunte o modificate nel backend/API layer) e restituisca i dati.
Implementare una funzione handleFilterResultsCausali o handleFilterResultsRicambi per aggiornare lo stato principale (causali o ricambi) con i dati filtrati.
Aggiungere un pulsante (es. nell'Header) per attivare/disattivare la visualizzazione di FilterSearch.
Renderizzare <FilterSearch fields={...} onSearch={...} onResults={...} /> condizionalmente.
Queste modifiche rendono FilterSearch un componente UI riutilizzabile per la raccolta di input di filtro, delegando la logica specifica di ricerca e gestione dei dati al componente padre.

Context Sources (6)

User
ci sono molti errori in MovimentiForm.jsx puoi sitemarmi il codice?


Gemini
Certamente! Ho analizzato il codice di MovimentiForm.jsx e ho identificato alcuni punti che necessitano di correzione per garantire il corretto funzionamento, specialmente dopo l'integrazione con il componente FilterSearch generico.

Ecco le modifiche proposte:

Stato message mancante: Lo stato message e la sua funzione setMessage sono utilizzati in diverse parti del componente per fornire feedback all'utente, ma la loro dichiarazione era assente.
Import di causaliApi mancante: La funzione fetchCausali utilizza causaliApi, ma l'import non era presente.
Prop onResults per FilterSearch: Il componente FilterSearch si aspetta una prop onResults per passare i dati filtrati al componente padre. Questa prop non veniva passata.
Rimozione import axios non utilizzato: L'import di axios non sembra essere utilizzato direttamente, poiché le chiamate API sono gestite tramite i moduli *Api.js.
Ecco il diff con le correzioni applicate al file MovimentiForm.jsx:

MovimentiForm.jsx
-2
+4
import TableGrid from "./TableGrid";
import MovimentiDialogCustom from "./MovimentiDialogCustom";
import movimentiApi from "../api/movimentiApi"; // API per le operazioni sui movimenti
import ricambiApi from "../api/ricambiApi"; // API per gli articoli/ricambi
import axios from "axios"; // Per caricare le causali (temporaneo, idealmente via API dedicata)
import ricambiApi from "../api/ricambiApi"; // API per gli articoli/ricambi
import causaliApi from "../api/causaliApi"; // API per le causali
import Header from "./Header"; // Aggiunto import per Header

const rowsPerPageOptions = [5, 10, 20, 50];
  const [sortKey, setSortKey] = useState("data");
  const [sortOrder, setSortOrder] = useState("desc");
  const [loadingTable, setLoadingTable] = useState(false);
  const [message, setMessage] = useState(""); // Stato per i messaggi all'utente
  
  const [loadingArticoli, setLoadingArticoli] = useState(false);
  const [loadingCausali, setLoadingCausali] = useState(false);
        <FilterSearch
          fields={movimentiFilterFields} // Pass the defined fields
          onSearch={handleSearchMovimenti} // Pass the search handler function
          onResults={handleFilterResults} // Pass the results handler
        ></FilterSearch>
        )}


Spiegazione delle correzioni:

const [message, setMessage] = useState("");

È stato aggiunto lo stato message per memorizzare e visualizzare messaggi di feedback (successo, errore, informazioni) all'utente.
import causaliApi from "../api/causaliApi";

È stato aggiunto l'import necessario per causaliApi, utilizzato dalla funzione fetchCausali per caricare l'elenco delle causali.
Rimozione di import axios from "axios";

L'import di axios è stato rimosso poiché non viene utilizzato direttamente nel componente. Le chiamate API sono gestite attraverso i moduli specifici (movimentiApi, ricambiApi, causaliApi). Se axios fosse necessario all'interno di questi moduli API, sarebbe importato lì.
onResults={handleFilterResults} in <FilterSearch />

La prop onResults è stata aggiunta all'invocazione del componente FilterSearch. Ora, quando FilterSearch completa una ricerca, chiamerà handleFilterResults con i dati ottenuti, permettendo a MovimentiForm di aggiornare la tabella.
Con queste modifiche, il componente MovimentiForm.jsx dovrebbe funzionare correttamente con il FilterSearch generico e gestire in modo appropriato il feedback all'utente.

Context Sources (5)

User
puoi corrgg[{ "resource": "/c:/maga/maga/src/components/MovimentiForm.jsx", "owner": "typescript", "code": "1128", "severity": 8, "message": "Declaration or statement expected.", "source": "ts", "startLineNumber": 638, "startColumn": 1, "endLineNumber": 638, "endColumn": 2 },{ "resource": "/c:/maga/maga/src/components/MovimentiForm.jsx", "owner": "typescript", "code": "1128", "severity": 8, "message": "Declaration or statement expected.", "source": "ts", "startLineNumber": 107, "startColumn": 1, "endLineNumber": 107, "endColumn": 2 },{ "resource": "/c:/maga/maga/src/components/MovimentiForm.jsx", "owner": "typescript", "code": "1005", "severity": 8, "message": "'try' expected.", "source": "ts", "startLineNumber": 101, "startColumn": 5, "endLineNumber": 101, "endColumn": 10 },{ "resource": "/c:/maga/maga/src/components/MovimentiForm.jsx", "owner": "typescript", "code": "1128", "severity": 8, "message": "Declaration or statement expected.", "source": "ts", "startLineNumber": 101, "startColumn": 3, "endLineNumber": 101, "endColumn": 4 },{ "resource": "/c:/maga/maga/src/components/MovimentiForm.jsx", "owner": "typescript", "code": "1128", "severity": 8, "message": "Declaration or statement expected.", "source": "ts", "startLineNumber": 98, "startColumn": 7, "endLineNumber": 98, "endColumn": 11 },{ "resource": "/c:/maga/maga/src/components/MovimentiForm.jsx", "owner": "typescript", "code": "1128", "severity": 8, "message": "Declaration or statement expected.", "source": "ts", "startLineNumber": 97, "startColumn": 7, "endLineNumber": 97, "endColumn": 8 }]ere gli errori che ti ho inivato in chat

Selected text
: 1 lines selected
Selected text
: 1 lines selected
Selected text
: 1 lines selected
Selected text
: 1 lines selected
Selected text
: 1 lines selected
Selected text
: 1 lines selected
Selected text
: 1 lines selected

Gemini
Gli errori che hai segnalato indicano problemi di sintassi nel tuo file MovimentiForm.jsx, principalmente legati a parentesi graffe {} mancanti, extra o posizionate in modo errato. Questi errori interrompono la struttura dei blocchi di codice come try...catch e if...else.

Ecco un'analisi e come puoi correggerli:

Errore alla riga 638 (Declaration or statement expected.):

Se il tuo componente MovimentiForm è definito e si conclude correttamente (ad esempio, con una } alla riga 637 che chiude la funzione del componente), una parentesi graffa } aggiuntiva alla riga 638 è un errore di sintassi.
Correzione: Rimuovi questa parentesi graffa } extra se si trova dopo la fine della definizione del componente.
Errori intorno alle righe 97-107 (principalmente nelle funzioni handleSearchMovimenti e/o handleFilterResults):

L'errore più indicativo è 'try' expected. alla riga 101, dove probabilmente hai un blocco catch. Questo errore si verifica quando il blocco catch non è preceduto immediatamente da un blocco try correttamente chiuso.
Gli errori Declaration or statement expected. in queste righe, specialmente se associati a }, else, o catch, suggeriscono che i blocchi if o try non sono chiusi nel punto giusto, ci sono parentesi graffe spurie, o la sequenza dei blocchi è errata.
Struttura corretta delle funzioni potenzialmente problematiche:

Assicurati che le tue funzioni handleSearchMovimenti e handleFilterResults seguano una struttura simile a questa, prestando molta attenzione all'annidamento e alla chiusura delle parentesi graffe:

javascriptreact
// Inizio della funzione handleSearchMovimenti
const handleSearchMovimenti = async (filterValues) => {
  try { // Blocco try principale
    const query = {};
    if (filterValues.idart) query.idart = filterValues.idart;
    if (filterValues.idcau) query.idcau = filterValues.idcau;
    if (filterValues.tipo) query.tipo = filterValues.tipo;
    if (filterValues.dataDa) query.dataDa = filterValues.dataDa;
    if (filterValues.dataA) query.dataA = filterValues.dataA;

    const res = await movimentiApi.fetchByFilters(query);

    if (res.success && Array.isArray(res.data)) { // Blocco if (interno al try)
      return res.data.map((m) => ({
        ...m,
        data: m.data
          ? new Date(m.data).toISOString().slice(0, 10)
          : "",
      }));
    } else { // Blocco else (per l'if precedente)
      throw new Error(res.error || "Dati filtrati non validi.");
    } // Chiusura del blocco else
  } catch (err) { // Blocco catch (per il try principale)
    console.error("Errore nei filtri:", err);
    throw new Error(`Errore nella ricerca: ${err.message || err}`);
  } // Chiusura del blocco catch
}; // Chiusura della funzione handleSearchMovimenti

// Inizio della funzione handleFilterResults
const handleFilterResults = (resultsFromSearch) => {
  setLoadingTable(true);
  setMessage("");
  try { // Blocco try principale
    if (Array.isArray(resultsFromSearch)) { // Blocco if (interno al try)
      setMovimenti(resultsFromSearch);
      if (resultsFromSearch.length === 0) {
        setMessage("ℹ️ Nessun movimento trovato con i filtri specificati.");
      }
    } else { // Blocco else (per l'if precedente)
      throw new Error("I risultati della ricerca non sono validi.");
    } // Chiusura del blocco else
  } catch (err) { // Blocco catch (per il try principale)
    console.error("Errore nell'elaborazione dei risultati del filtro:", err);
    setMessage(`❌ Errore nell'elaborazione dei risultati: ${err.message || err}`);
    setMovimenti([]);
  } finally { // Blocco finally
    setLoadingTable(false);
  } // Chiusura del blocco finally
}; // Chiusura della funzione handleFilterResults
Cosa devi controllare e correggere nel tuo codice:

Parentesi Graffe Bilanciate: Assicurati che ogni parentesi graffa di apertura { abbia la sua corrispondente parentesi graffa di chiusura }. Un editor di codice con evidenziazione delle parentesi può essere molto utile.
Struttura try...catch...finally:
Un blocco catch deve seguire immediatamente la parentesi graffa di chiusura } di un blocco try.
Un blocco finally deve seguire immediatamente la } di un blocco try o la } di un blocco catch.
Non ci deve essere altro codice tra la fine di un try e l'inizio del catch, o tra la fine di un catch e l'inizio del finally (se il finally segue il catch).
Struttura if...else:
Un blocco else deve seguire immediatamente la parentesi graffa di chiusura } di un blocco if.
Azione consigliata:

Rimuovi la } extra alla riga 638 se si trova dopo la chiusura del tuo componente MovimentiForm.
Confronta attentamente le tue funzioni handleSearchMovimenti e handleFilterResults (specialmente intorno alle righe 97-107 del tuo file) con gli esempi corretti forniti sopra. Presta particolare attenzione alla posizione e al numero di parentesi graffe. È probabile che una } sia nel posto sbagliato (ad esempio, chiudendo un try troppo presto) o che ne manchi una.
Se, dopo aver controllato questi punti, hai ancora problemi, per favore fornisci la porzione di codice specifica del tuo file MovimentiForm.jsx che contiene gli errori (ad esempio, le righe da circa 90 a 120 e le ultime righe del file), così potrò aiutarti in modo più mirato.

Context Sources (15)

User
Query generata: SELECT m.id, m.quantita, c.description AS descriptioncau, m.tipo, m.idart, m.idcau, m.note, m.data FROM movimenti m JOIN articoli a ON m.idart = a.id JOIN causali c ON m.idcau = c.id WHERE m.idart = 5 ORDER BY m.data DESC;


Gemini
La query che hai fornito è quasi completa per recuperare i dati necessari per la TableGrid nel componente MovimentiForm.

Tuttavia, come puoi vedere dalla definizione delle colonne in MovimentiForm.jsx:

javascriptreact
// Definizione colonne per la tabella
const tableColumns = [
  // ... altre colonne ...
  { key: "descriptionart", label: "Articolo", cellClassName: "text-left" },
  { key: "descriptioncau", label: "Causale", cellClassName: "text-left" },
  // ... altre colonne ...
];
La tabella si aspetta un campo descriptionart per visualizzare il nome/descrizione dell'articolo. La tua query attuale seleziona c.description AS descriptioncau per la causale, ma manca una selezione simile per l'articolo.

Dato che la tua query include già JOIN articoli a ON m.idart = a.id, hai accesso ai dati della tabella articoli. Devi solo aggiungere il campo appropriato (presumibilmente a.name o a.description) alla clausola SELECT e dargli l'alias descriptionart.

Ecco come dovresti modificare la tua query:

sql
SELECT
  m.id,
  m.quantita,
  a.name AS descriptionart,  -- <<< Aggiungi questa riga (o a.description se il campo si chiama così)
  c.description AS descriptioncau,
  m.tipo,
  m.idart,
  m.idcau,
  m.note,
  m.data
FROM movimenti m
JOIN articoli a ON m.idart = a.id
JOIN causali c ON m.idcau = c.id
WHERE m.idart = 5 ORDER BY m.data DESC;
Modifica chiave: Ho aggiunto a.name AS descriptionart. Se il campo nella tua tabella articoli che contiene la descrizione dell'articolo si chiama diversamente (ad esempio, description), dovrai usare a.description AS descriptionart.

Questa modifica deve essere apportata nel punto in cui questa query SQL viene effettivamente generata ed eseguita, che di solito è:

Nel backend: se movimentiApi.fetchByFilters chiama un endpoint API che costruisce ed esegue questa query.
Nel layer API frontend (movimentiApi.js): se questo file costruisce dinamicamente query SQL (meno comune per le chiamate API dirette, ma possibile se si usa qualcosa come sql.js o si inviano query testuali).
Assicurandoti che la query SQL selezioni descriptionart, i dati restituiti a MovimentiForm.jsx conterranno questo campo, e la TableGrid sarà in grado di visualizzare correttamente la descrizione dell'articolo.

Context Sources (14)

User
la query viene eseguita da mivimentcontrollers.js


Gemini
Capisco. Se la query viene eseguita da movimenticontrollers.js, e ti riferisci alla necessità di includere descriptionart (la descrizione dell'articolo) quando si applicano filtri, la soluzione migliore è assicurarsi che la funzione controller che gestisce la richiesta di dati filtrati costruisca una query SQL che includa quel campo.

Attualmente, nel tuo movimenticontrollers.js:

La funzione customQuery esegue una stringa SQL che le viene passata direttamente dal frontend. Se quella stringa SQL non include a.name AS descriptionart (o un alias simile per la descrizione dell'articolo), allora il risultato non lo conterrà. In questo caso, la modifica andrebbe fatta nel frontend, dove la stringa SQL viene costruita prima di essere inviata a customQuery.
La funzione getMovimenti recupera tutti i movimenti e la sua query SQL include già a.name as descriptionart.
Se vuoi che la logica di filtraggio risieda nel backend e che restituisca sempre descriptionart, possiamo modificare la funzione getMovimenti per accettare parametri di filtro. In questo modo, il frontend invierebbe solo i valori dei filtri (es. idart=5, tipo=C) e il backend costruirebbe la query SQL sicura e completa.

Ecco come potresti modificare getMovimenti in movimenticontrollers.js per gestire i filtri:

movimenticontrollers.js
-8
+37

// GET tutti i movimenti (potresti voler aggiungere filtri, es. per articolo o data)
exports.getMovimenti = async (req, res) => {
  // Estrai i possibili filtri dalla query string dell'URL (es. /api/movimenti?idart=1&tipo=C)
  const { idart, idcau, tipo, dataDa, dataA } = req.query;

  try {
    // Esempio: potresti voler fare un JOIN per ottenere anche il nome dell'articolo e la descrizione della causale
    
    const [rows] = await db.query(`
      SELECT 
    let sqlQuery = `
      SELECT
        m.id, 
        m.data, 
        m.quantita, 
      FROM movimenti m
      JOIN articoli a ON m.idart = a.id
      JOIN causali c ON m.idcau = c.id
      ORDER BY m.data DESC
    `);
      //console.log("Query eseguita. Risultati:", rows);
    `;

    const conditions = [];
    const params = [];

    if (idart) {
      conditions.push("m.idart = ?");
      params.push(idart);
    }
    if (idcau) {
      conditions.push("m.idcau = ?");
      params.push(idcau);
    }
    if (tipo) {
      conditions.push("m.tipo = ?");
      params.push(tipo);
    }
    if (dataDa) {
      conditions.push("m.data >= ?");
      params.push(dataDa);
    }
    if (dataA) {
      // Per includere tutta la giornata, si potrebbe usare dataA + ' 23:59:59' se il campo data è DATETIME
      // Se è DATE, <= va bene.
      conditions.push("m.data <= ?");
      params.push(dataA);
    }

    if (conditions.length > 0) {
      sqlQuery += " WHERE " + conditions.join(" AND ");
    }

    sqlQuery += " ORDER BY m.data DESC";
    const [rows] = await db.query(sqlQuery, params);
    res.json({ success: true, data: rows });
    //console.log({data: rows});
   } catch (error) {
     console.error("Errore nel recupero dei movimenti:", error);
     res.status(500).json({ success: false, error: error.message });

Cosa fa questa modifica:

La funzione getMovimenti ora può ricevere parametri di filtro (come idart, idcau, tipo, dataDa, dataA) attraverso la query string dell'URL (es. GET /api/movimenti?idart=5&tipo=C).
Costruisce dinamicamente la clausola WHERE della query SQL basandosi sui filtri forniti.
Utilizza query parametrizzate (? e l'array params) per prevenire SQL injection.
La query base seleziona già a.name as descriptionart, quindi questo campo sarà sempre presente nei risultati, anche quando filtrati.
Modifiche necessarie nel Frontend (concettuali): Se adotti questo approccio, il tuo frontend (specificamente la funzione in movimentiApi.js chiamata da handleSearchMovimenti in MovimentiForm.jsx, che presumibilmente è fetchByFilters) dovrebbe:

Non costruire una stringa SQL.
Invece, effettuare una richiesta GET all'endpoint /api/movimenti (o quello mappato a movimentiController.getMovimenti).
Passare i valori dei filtri come parametri nella query string dell'URL. Ad esempio, se filterValues è { idart: "5", tipo: "C" }, la richiesta API dovrebbe essere qualcosa come axios.get('/api/movimenti?idart=5&tipo=C').
Questo approccio è generalmente più sicuro e manutenibile perché la logica SQL è centralizzata nel backend.

Se, invece, devi assolutamente continuare a usare la funzione customQuery inviando una stringa SQL completa dal frontend, allora la responsabilità di includere a.name AS descriptionart nella stringa SQL ricade interamente sul codice frontend che genera quella stringa. Il controller customQuery eseguirà semplicemente ciò che riceve.

Context Sources (15)

User
E' mia intenzione anche per la GET la PUT e la DELETE request creare la query dal front-end ed inviare nella request al back end


Gemini
Capisco la tua intenzione di voler inviare query SQL complete dal frontend al backend per le operazioni GET (filtrate), PUT e DELETE sui movimenti. Questo ti darebbe massima flessibilità nel frontend, ma è cruciale essere consapevoli di alcune implicazioni significative.

Prima di mostrarti le modifiche al codice, considera attentamente i seguenti punti:

Sicurezza (Rischio Elevato di SQL Injection):

Inviare stringhe SQL grezze dal frontend al backend è una pratica altamente sconsigliata perché espone il tuo database a un rischio بسیار elevato di attacchi SQL Injection. Se un utente malintenzionato riuscisse a manipolare la query inviata, potrebbe leggere, modificare o cancellare dati arbitrari dal tuo database.
L'approccio standard e più sicuro prevede che il backend riceva solo i parametri per la query, e sia il backend stesso a costruire la query SQL in modo sicuro (usando query parametrizzate/prepared statements).
Logica di Business e Transazioni:

Attualmente, le operazioni di inserimento (insertMovimento) e cancellazione (deleteMovimento) nel tuo controller gestiscono la logica di aggiornamento delle giacenze degli articoli e utilizzano transazioni per garantire l'atomicità (o tutto o niente).
Se il frontend invia la query SQL completa per UPDATE o DELETE, questa logica transazionale e di aggiornamento delle giacenze presente nel backend verrebbe bypassata. La responsabilità di garantire la consistenza dei dati (es. aggiornare correttamente le giacenze quando un movimento viene modificato o eliminato) si sposterebbe interamente al frontend. Questo può rendere il codice frontend più complesso e aumentare il rischio di errori o inconsistenze nei dati.
Standard API e Manutenibilità:

Inviare query SQL complete come parametri di richieste GET o nel corpo di richieste PUT/DELETE non è una pratica REST standard. Può rendere l'API meno intuitiva e più difficile da manutenere e testare.
Se, nonostante queste considerazioni, desideri procedere, ecco come potresti modificare movimenticontrollers.js:

La rotta POST /customquery che hai già implementato è il modo più appropriato per inviare query SELECT complesse dal frontend. Per le operazioni di GET filtrata, ti consiglio di utilizzare quella.

Tuttavia, per seguire la tua richiesta di modificare anche le rotte GET, PUT e DELETE standard:

movimenticontrollers.js
-91
+54
The code change produced by Gemini cannot be automatically applied. You can manually apply the change or ask Gemini to try again.

// GET tutti i movimenti (potresti voler aggiungere filtri, es. per articolo o data)
exports.getMovimenti = async (req, res) => {
  // Se viene fornita una query SQL specifica come parametro URL, esegui quella.
  // Esempio di chiamata dal frontend: /api/movimenti?sqlQueryString=SELECT...
  const { sqlQueryString } = req.query;

  try {
    // Esempio: potresti voler fare un JOIN per ottenere anche il nome dell'articolo e la descrizione della causale
    
    const [rows] = await db.query(`
      SELECT 
        m.id, 
        m.data, 
        m.quantita, 
        a.name as descriptionart, 
        c.description as descriptioncau,
        m.tipo,
        m.idart,
        m.idcau,
        m.note
      FROM movimenti m
      JOIN articoli a ON m.idart = a.id
      JOIN causali c ON m.idcau = c.id
      ORDER BY m.data DESC
    `);
      //console.log("Query eseguita. Risultati:", rows);

    res.json({ success: true, data: rows });
    //console.log({data: rows});
  if (sqlQueryString && typeof sqlQueryString === 'string') {
    try {
      console.warn("Esecuzione di query SQL personalizzata per GET /api/movimenti. Rischio SQL Injection se non sanitizzata.");
      const [rows] = await db.query(sqlQueryString);
      return res.json({ success: true, data: rows });
    } catch (error) {
      console.error("Errore nella query GET personalizzata per movimenti:", error);
      return res.status(500).json({ success: false, error: error.message });
    }
  }

  // Logica di default: recupera tutti i movimenti con join
  try {
    const [rows] = await db.query(`
      SELECT m.id, m.data, m.quantita, a.name as descriptionart, c.description as descriptioncau, m.tipo, m.idart, m.idcau, m.note
      FROM movimenti m
      JOIN articoli a ON m.idart = a.id
      JOIN causali c ON m.idcau = c.id
      ORDER BY m.data DESC`);
    res.json({ success: true, data: rows });
  } catch (error) {
    console.error("Errore nel recupero dei movimenti:", error);
    res.status(500).json({ success: false, error: error.message });
  }
};

// PUT: modifica movimento (ATTENZIONE: modificare un movimento può essere complesso)
// La modifica di un movimento spesso implica stornare il vecchio movimento e crearne uno nuovo,
// o ricalcolare le giacenze. Questa è una semplificazione.
// PUT: modifica movimento eseguendo una query SQL fornita dal frontend.
// ATTENZIONE: Questo bypassa la logica transazionale e di aggiornamento giacenze del backend.
exports.updateMovimento = async (req, res) => {
  const { id } = req.params; // L'ID nella rotta potrebbe essere ridondante se la query lo specifica già.
  // Considera quali campi di un movimento possono essere modificati e l'impatto sulle giacenze.
  // Questa è una funzione complessa da implementare correttamente.
  // Per ora, un placeholder:
  console.warn(
    `La modifica del movimento ${id} non è completamente implementata e può avere effetti collaterali sulle giacenze.`
  );
  const { note } = req.body; // Esempio: permettiamo solo di modificare le note
  if (note === undefined) {
  const { sqlQueryString } = req.body;

  if (!sqlQueryString || typeof sqlQueryString !== 'string') {
    return res
      .status(400)
      .json({
        success: false,
        error:
          "Nessun dato fornito per l'aggiornamento o campo non modificabile.",
        error: "Query SQL mancante o non valida per l'aggiornamento.",
      });
  }

  try {
    await db.query("UPDATE movimenti SET note=? WHERE id=?", [note, id]);
    res.json({ success: true, message: "Nota movimento aggiornata." });
    console.warn(`Esecuzione di query SQL personalizzata per PUT /api/movimenti/${id}. Rischio SQL Injection e potenziale inconsistenza dati (giacenze).`);
    const [result] = await db.query(sqlQueryString);
    if (result.affectedRows === 0) {
      return res.status(404).json({ success: false, error: "Nessun movimento aggiornato dalla query (ID non trovato o query non efficace)." });
    }
    res.json({ success: true, message: "Query di aggiornamento movimento eseguita.", affectedRows: result.affectedRows });
  } catch (error) {
    console.error("Errore durante l'aggiornamento del movimento:", error);
    res.status(500).json({ success: false, error: error.message });
};

// DELETE: elimina movimento (ATTENZIONE: eliminare un movimento richiede di stornare l'effetto sulla giacenza)
// Questa è una semplificazione.
// ATTENZIONE: Questo bypassa la logica transazionale e di storno giacenze del backend.
exports.deleteMovimento = async (req, res) => {
  const { id } = req.params;
  let connection;
  const { sqlQueryString } = req.body;

  if (!sqlQueryString || typeof sqlQueryString !== 'string') {
    return res
      .status(400)
      .json({
        success: false,
        error: "Query SQL mancante o non valida per l'eliminazione.",
      });
  }

  try {
    connection = await db.getConnection();
    await connection.beginTransaction();

    // 1. Ottieni i dettagli del movimento da eliminare per stornare la quantità
    const [movimentoDaEliminareRows] = await connection.query(
      "SELECT idart, quantita, tipo FROM movimenti WHERE id = ?",
      [id]
    );
    if (movimentoDaEliminareRows.length === 0) {
      await connection.rollback();
      return res
        .status(404)
        .json({ success: false, error: "Movimento non trovato." });
    }
    const movimentoDaEliminare = movimentoDaEliminareRows[0];

    // 2. Storna l'effetto sulla quantità dell'articolo
    let queryStornoArticolo;
    if (movimentoDaEliminare.tipo === "C") {
      // Se era un carico, ora devo scaricare (sottrarre)
      queryStornoArticolo =
        "UPDATE articoli SET quantita = quantita - ? WHERE id = ?";
    } else if (movimentoDaEliminare.tipo === "S") {
      // Se era uno scarico, ora devo caricare (aggiungere)
      queryStornoArticolo =
        "UPDATE articoli SET quantita = quantita + ? WHERE id = ?";
    } else {
      await connection.rollback();
      return res
        .status(400)
        .json({
          success: false,
          error: "Tipo movimento del record da eliminare non valido.",
        });
    }
    await connection.query(queryStornoArticolo, [
      movimentoDaEliminare.quantita,
      movimentoDaEliminare.idart,
    ]);

    // 3. Elimina il movimento
    await connection.query("DELETE FROM movimenti WHERE id=?", [id]);

    await connection.commit();
    res.json({
      success: true,
      message: "Movimento eliminato e giacenza articolo aggiornata.",
    });
    console.warn(`Esecuzione di query SQL personalizzata per DELETE /api/movimenti/${id}. Rischio SQL Injection e potenziale inconsistenza dati (giacenze).`);
    const [result] = await db.query(sqlQueryString);
    if (result.affectedRows === 0) {
      return res.status(404).json({ success: false, error: "Nessun movimento eliminato dalla query (ID non trovato o query non efficace)." });
    }
    res.json({ success: true, message: "Query di eliminazione movimento eseguita.", affectedRows: result.affectedRows });
  } catch (error) {
    if (connection) await connection.rollback();
    console.error("Errore durante l'eliminazione del movimento:", error);
    res.status(500).json({ success: false, error: error.message });
  } finally {
    if (connection) connection.release();
   }
 };

Spiegazione delle modifiche:

exports.getMovimenti (per GET /api/movimenti):

Ora controlla se nella query string dell'URL è presente un parametro sqlQueryString.
Se c'è, tenta di eseguire quella query. Nota: Passare SQL complesse via URL è limitato in lunghezza e problematico per caratteri speciali. La rotta POST /customquery è più adatta per query SELECT complesse.
Se sqlQueryString non è presente, esegue la query di default per ottenere tutti i movimenti con i join (come faceva prima, assicurando descriptionart).
exports.updateMovimento (per PUT /api/movimenti/:id):

Ora si aspetta una proprietà sqlQueryString nel corpo (req.body) della richiesta.
Esegue direttamente questa query SQL.
Importante: Tutta la logica precedente per aggiornare solo le note e gestire le transazioni/giacenze è stata rimossa. La query inviata dal frontend è ora responsabile di tutta la logica di aggiornamento.
exports.deleteMovimento (per DELETE /api/movimenti/:id):

Similmente all'update, si aspetta sqlQueryString in req.body.
Esegue direttamente questa query SQL.
Importante: Tutta la logica precedente per lo storno delle giacenze e la gestione delle transazioni è stata rimossa.
Come il frontend dovrebbe interagire (esempio concettuale):

Per GET filtrata (sconsigliato via GET per query complesse, meglio usare POST /customquery):

javascript
// In movimentiApi.js o simile
// async fetchMovimentiByCustomQueryGET(queryString) {
//   // queryString dovrebbe essere URL-encoded
//   const response = await axios.get(`/api/movimenti?sqlQueryString=${encodeURIComponent(queryString)}`);
//   return response.data;
// }
Per UPDATE:

javascript
// In movimentiApi.js o simile
// async updateMovimentoWithCustomQuery(movimentoId, updateQueryString) {
//   const response = await axios.put(`/api/movimenti/${movimentoId}`, { sqlQueryString: updateQueryString });
//   return response.data;
// }
// Esempio di updateQueryString (costruita nel frontend):
// "UPDATE movimenti SET note = 'Nuova nota', quantita = 5 WHERE id = 123; UPDATE articoli SET quantita = quantita - 2 WHERE id = (SELECT idart FROM movimenti WHERE id = 123);"
// (Questo esempio è semplificato e non gestisce correttamente le transazioni se le due query devono essere atomiche)
Per DELETE:

javascript
// In movimentiApi.js o simile
// async deleteMovimentoWithCustomQuery(movimentoId, deleteQueryString) {
//   // L'id nella rotta è quasi ignorato se la query fa tutto
//   const response = await axios.delete(`/api/movimenti/${movimentoId}`, { data: { sqlQueryString: deleteQueryString } }); // Nota: `data` per DELETE con Axios
//   return response.data;
// }
// Esempio di deleteQueryString (costruita nel frontend):
// "DELETE FROM movimenti WHERE id = 123; UPDATE articoli SET quantita = quantita + (SELECT quantita FROM movimenti WHERE id = 123 AND tipo='S') WHERE id = (SELECT idart FROM movimenti WHERE id = 123);"
// (Anche questo è semplificato e non gestisce transazioni)
Raccomandazione Finale: Ti esorto vivamente a riconsiderare l'invio di query SQL complete dal frontend, specialmente per le operazioni di modifica (PUT, DELETE) a causa dei rischi di sicurezza e della complessità nella gestione della logica di business e delle transazioni. L'approccio più robusto e sicuro è mantenere la costruzione delle query SQL e la logica di business (incluse transazioni e aggiornamento giacenze) nel backend, esponendo API che accettano solo i parametri necessari.

Se decidi di procedere con questo metodo, assicurati di implementare misure di sicurezza molto rigorose nel frontend per prevenire la costruzione di query malevole, anche se questo rimane intrinsecamente meno sicuro.

Context Sources (49)

User
e centralizzare le api nella directory controller è vantaggioso dal punto di vista e performante?


Gemini
Sì, centralizzare la logica delle API nella directory controllers (come stai facendo nel tuo progetto Node.js/Express) è una pratica molto vantaggiosa e considerata uno standard in molte architetture backend, come l'MVC (Model-View-Controller) o architetture a strati simili.

Ecco perché è vantaggioso e cosa implica per le performance:

Vantaggi della Centralizzazione nei Controller:

Separazione delle Responsabilità (Separation of Concerns):

I controller diventano il punto in cui la richiesta HTTP (proveniente dalle rotte) viene ricevuta ed elaborata.
Si occupano di:
Estrarre i dati dalla richiesta (req.params, req.query, req.body).
Validare i dati ricevuti (anche se spesso la validazione più complessa è delegata a un livello di servizio o validatori dedicati).
Chiamare la logica di business appropriata (spesso in un livello di "servizi" o "manager") per eseguire l'operazione richiesta (es. inserire un movimento, aggiornare un ricambio).
Interagire con il livello di accesso ai dati (es. chiamare le funzioni nel tuo db.js o un ORM) per eseguire query sul database.
Formattare la risposta da inviare al client (res.json, res.status).
Questo mantiene le rotte (routes) pulite (si limitano a mappare URL a funzioni controller) e la logica di accesso ai dati (db.js) focalizzata solo sull'interazione con il DB.
Organizzazione e Manutenibilità:

Il codice è più facile da trovare e capire. Sai che la logica per gestire le richieste relative ai movimenti si trova in movimenticontrollers.js, quella per i ricambi in ricambicontrollers.js, ecc.
Quando devi modificare come viene gestita una specifica richiesta API, sai esattamente dove cercare.
Riutilizzabilità:

Sebbene nel tuo caso specifico ogni controller gestisca un'entità diversa, in applicazioni più grandi potresti avere funzioni di utilità o logica condivisa che possono essere chiamate da diversi controller. Centralizzare la logica di business (anche se non strettamente nel controller, ma chiamata dal controller) facilita il riutilizzo.
Testabilità:

È più facile scrivere test unitari per le funzioni controller quando la loro logica è ben definita e separata dalla configurazione delle rotte o dalla logica di basso livello del database. Puoi "mockare" (simulare) le chiamate al database o ad altri servizi per testare solo la logica del controller.
Gestione degli Errori:

Centralizzare la logica di gestione degli errori (es. blocchi try...catch) all'interno dei controller o in middleware specifici chiamati dai controller rende la gestione degli errori più coerente e robusta.
Implicazioni sulle Performance:

Dal punto di vista delle performance, centralizzare la logica nei controller è generalmente neutro o leggermente positivo a causa della migliore organizzazione.

Non introduce overhead significativo: L'overhead di chiamare una funzione in un altro file è trascurabile rispetto ai tempi impiegati per le operazioni di I/O (input/output), come le chiamate al database o le comunicazioni di rete.
Può migliorare le performance indirettamente: Una codebase ben organizzata e manutenibile rende più facile identificare e ottimizzare i colli di bottiglia. Se la logica di accesso ai dati è separata, è più semplice lavorare sull'ottimizzazione delle query SQL o sull'indicizzazione del database senza dover toccare la logica di gestione della richiesta HTTP.
Le performance dipendono da:
Efficienza delle query SQL: Questo è il fattore più critico nella maggior parte delle applicazioni web. Query lente o mal ottimizzate avranno un impatto molto maggiore rispetto alla struttura del codice controller.
Carico del server e risorse disponibili: CPU, RAM, disco.
Latenza di rete: Tra il client e il server, e tra il server e il database.
Logica di business complessa: Se la logica eseguita dal controller (o dai servizi chiamati dal controller) è computazionalmente intensiva.
In sintesi:

Centralizzare la logica delle API nei controller è un'ottima pratica per l'organizzazione, la manutenibilità, la testabilità e la sicurezza (indirettamente, rendendo più facile applicare validazioni e usare query parametrizzate). Non ha un impatto negativo significativo sulle performance; al contrario, una struttura chiara può facilitare future ottimizzazioni.

La tua struttura attuale con routes che chiamano funzioni in controllers è un buon approccio standard.

Context Sources (49)

User
e unificare i controllere attauali ?


Gemini
Sì, "unificare" o meglio, standardizzare e refactorizzare i tuoi controller attuali può essere molto vantaggioso, principalmente dal punto di vista della manutenibilità, leggibilità e riduzione della duplicazione del codice (principio DRY - Don't Repeat Yourself). Dal punto di vista delle performance pure, l'impatto è generalmente trascurabile; le performance delle tue API dipenderanno molto di più dall'efficienza delle query al database e dalla logica di business specifica piuttosto che dalla struttura dei file dei controller.

Attualmente hai controller separati per ogni risorsa (movimenti, ricambi, causali, diba), il che è una buona pratica per la separazione delle responsabilità. L' "unificazione" non dovrebbe significare mettere tutto il codice in un unico file enorme, ma piuttosto identificare pattern comuni, specialmente per le operazioni CRUD (Create, Read, Update, Delete), e astrarli.

Strategia Proposta: Creare Handler CRUD Generici

Una strategia efficace è creare un insieme di funzioni (o una "factory" di funzioni) che gestiscano le operazioni CRUD di base in modo generico. Queste funzioni possono poi essere utilizzate dai tuoi controller specifici.

Questo approccio è particolarmente utile per i controller come ricambicontrollers.js, causalicontrollers.js, e dibacontrollers.js, dove le operazioni CRUD sono abbastanza standard. Il controller movimenticontrollers.js, con la sua logica di business più complessa (transazioni, aggiornamento giacenze), potrebbe utilizzare solo parzialmente questi handler generici o mantenere le sue implementazioni specifiche per insert, update, e delete.

Vantaggi:

Riduzione della Duplicazione: Eviti di riscrivere la stessa logica per "ottenere tutti", "ottenere per ID", "inserire", "aggiornare", "eliminare" in ogni controller.
Coerenza: Tutte le operazioni CRUD si comporteranno in modo simile attraverso le diverse API.
Manutenibilità: Se devi modificare il modo in cui viene gestita un'operazione CRUD base (es. logging, gestione errori standard), lo fai in un unico posto.
Testabilità: Gli handler generici possono essere testati una volta in modo isolato.
Esempio Concettuale di Handler CRUD Generici:

Potresti creare un file di utilità, ad esempio server/utils/crudHandlers.js:

javascript
// server/utils/crudHandlers.js
const db = require('../db/db');

function createCrudHandlers(tableName, { fieldsToSelect = '*', validateInput } = {}) {
  return {
    /**
     * Get all records from the table.
     */
    getAll: async (req, res) => {
      try {
        const [rows] = await db.query(`SELECT ${fieldsToSelect} FROM ${tableName}`);
        res.json({ success: true, data: rows });
      } catch (error) {
        console.error(`Error fetching all from ${tableName}:`, error);
        res.status(500).json({ success: false, error: error.message });
      }
    },

    /**
     * Get a single record by ID.
     */
    getById: async (req, res) => {
      const { id } = req.params;
      try {
        const [rows] = await db.query(`SELECT ${fieldsToSelect} FROM ${tableName} WHERE id = ?`, [id]);
        if (rows.length === 0) {
          return res.status(404).json({ success: false, error: `${tableName.slice(0, -1)} not found.` });
        }
        res.json({ success: true, data: rows[0] });
      } catch (error) {
        console.error(`Error fetching ${tableName} by ID ${id}:`, error);
        res.status(500).json({ success: false, error: error.message });
      }
    },

    /**
     * Create a new record.
     * Assumes req.body contains the data.
     * `validateInput` is an optional function to validate req.body.
     */
    create: async (req, res) => {
      if (validateInput) {
        const validationError = validateInput(req.body, 'create');
        if (validationError) {
          return res.status(400).json({ success: false, error: validationError });
        }
      }
      // Dynamically get columns and values from req.body
      // This is a simplified example; robust implementation needs careful handling of allowed fields.
      const columns = Object.keys(req.body);
      const values = Object.values(req.body);
      const placeholders = columns.map(() => '?').join(', ');

      if (columns.length === 0) {
        return res.status(400).json({ success: false, error: "No data provided for creation." });
      }

      try {
        const [result] = await db.query(
          `INSERT INTO ${tableName} (${columns.join(', ')}) VALUES (${placeholders})`,
          values
        );
        res.status(201).json({ success: true, id: result.insertId, message: `${tableName.slice(0, -1)} created successfully.` });
      } catch (error) {
        console.error(`Error creating ${tableName}:`, error);
        res.status(500).json({ success: false, error: error.message });
      }
    },

    /**
     * Update an existing record by ID.
     * Assumes req.body contains the data to update.
     * `validateInput` is an optional function to validate req.body.
     */
    update: async (req, res) => {
      const { id } = req.params;
      if (validateInput) {
        const validationError = validateInput(req.body, 'update');
        if (validationError) {
          return res.status(400).json({ success: false, error: validationError });
        }
      }

      const fieldsToUpdate = Object.keys(req.body);
      const values = Object.values(req.body);

      if (fieldsToUpdate.length === 0) {
        return res.status(400).json({ success: false, error: "No data provided for update." });
      }

      const setClause = fieldsToUpdate.map(field => `${field} = ?`).join(', ');

      try {
        const [result] = await db.query(
          `UPDATE ${tableName} SET ${setClause} WHERE id = ?`,
          [...values, id]
        );
        if (result.affectedRows === 0) {
          return res.status(404).json({ success: false, error: `${tableName.slice(0, -1)} not found for update.` });
        }
        res.json({ success: true, message: `${tableName.slice(0, -1)} updated successfully.` });
      } catch (error) {
        console.error(`Error updating ${tableName} with ID ${id}:`, error);
        res.status(500).json({ success: false, error: error.message });
      }
    },

    /**
     * Delete a record by ID.
     */
    delete: async (req, res) => {
      const { id } = req.params;
      try {
        const [result] = await db.query(`DELETE FROM ${tableName} WHERE id = ?`, [id]);
        if (result.affectedRows === 0) {
          return res.status(404).json({ success: false, error: `${tableName.slice(0, -1)} not found for deletion.` });
        }
        res.json({ success: true, message: `${tableName.slice(0, -1)} deleted successfully.` });
      } catch (error) {
        console.error(`Error deleting ${tableName} with ID ${id}:`, error);
        res.status(500).json({ success: false, error: error.message });
      }
    },
  };
}

module.exports = { createCrudHandlers };
Come usare gli Handler Generici (Esempio per ricambicontrollers.js):

ricambicontrollers.js
-56
+18
//@author: "villari.andrea@libero.it"
//@version: "1.0.0 2025-06-09"
//==========================================
const db = require("../db/db");
const { createCrudHandlers } = require('../utils/crudHandlers'); // Assumendo che il file sia in utils

(async () => {
  try {
  }
})();

// GET tutti i ricambi
exports.getRicambi = async (req, res) => {
  try {
    const [rows] = await db.query("SELECT * FROM articoli");
    res.json({ success: true, data: rows });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
// Funzione di validazione specifica per i ricambi (opzionale, ma consigliata)
function validateRicambioInput(data, operation) {
  const { name, description, quantita, min, max, supplier } = data;
  if (!name || description === undefined || quantita === undefined || min === undefined || max === undefined || supplier === undefined) {
    return "Dati mancanti o incompleti per il ricambio.";
  }
};
  if (isNaN(Number(quantita)) || Number(quantita) < 0) {
    return "La quantità deve essere un numero non negativo.";
  }
  // Aggiungere altre validazioni se necessario
  return null; // Nessun errore
}

// POST: nuovo ricambio
exports.insertRicambio = async (req, res) => {
  const { name, description, quantita, min, max, supplier } = req.body;
  // Controllo dei campi obbligatori (supplier potrebbe essere opzionale a seconda della definizione del DB)
  if (!name || description === undefined || quantita === undefined || min === undefined || max === undefined || supplier === undefined) {
    return res.status(400).json({ success: false, error: "Dati mancanti o incompleti per il ricambio." });
  }
const ricambiCrudHandlers = createCrudHandlers('articoli', { validateInput: validateRicambioInput });

  try {
    const [result] = await db.query(
      "INSERT INTO articoli (name, description, quantita, min, max, supplier) VALUES (?, ?, ?, ?, ?, ?)",
      [name, description, quantita, min, max, supplier]
    );
    res.status(201).json({ success: true, id: result.insertId, message: "Ricambio inserito con successo" });
  } catch (error) {
    console.error("Errore durante l'inserimento del ricambio:", error);
    res.status(500).json({ success: false, error: error.message });
  }
};

// PUT: modifica ricambio
exports.updateRicambio = async (req, res) => {
  const { id } = req.params;
  const { name, description, quantita, min, max, supplier} = req.body;
  if (!name || description === undefined || quantita === undefined || min === undefined || max === undefined || supplier === undefined) {
    return res.status(400).json({ success: false, error: "Dati mancanti o incompleti per l'aggiornamento del ricambio." });
  }
  try {
    await db.query(
      "UPDATE articoli SET name=?, description=?, quantita=?, min=?, max=?, supplier=? WHERE id=?",
      [name, description, quantita, min, max, supplier,id]
    );
    res.json({ success: true, message: "Ricambio aggiornato con successo" });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
};

// DELETE: elimina ricambio
exports.deleteRicambio = async (req, res) => {
  const { id } = req.params;
  try {
    await db.query("DELETE FROM articoli WHERE id=?", [id]);
    res.json({ success: true, message: "Ricambio eliminato con successo" });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
};
exports.getRicambi = ricambiCrudHandlers.getAll;
exports.insertRicambio = ricambiCrudHandlers.create;
exports.updateRicambio = ricambiCrudHandlers.update;
exports.deleteRicambio = ricambiCrudHandlers.delete;
// Potresti aggiungere exports.getRicambioById = ricambiCrudHandlers.getById; se necessario

Considerazioni aggiuntive:

Validazione: L'esempio createCrudHandlers include un parametro opzionale validateInput. È fondamentale validare sempre i dati provenienti dal client. Questa funzione di validazione può essere specifica per ogni entità.
Campi da Selezionare/Aggiornare: L'handler create e update nell'esempio sono semplificati e usano Object.keys(req.body). In un'applicazione reale, dovresti avere una lista definita di campi permessi per evitare che un utente possa inserire/aggiornare colonne arbitrarie.
Logica di Business Specifica: Per movimenticontrollers.js, le operazioni insertMovimento e deleteMovimento (e potenzialmente updateMovimento) hanno una logica di business complessa (transazioni, aggiornamento giacenze). Queste probabilmente rimarranno implementazioni personalizzate. Tuttavia, getMovimenti potrebbe usare ricambiCrudHandlers.getAll se la query di base fosse adattata o se si passasse una stringa di query più complessa all'handler (anche se ciò ridurrebbe la generalità).
Sicurezza della customQuery: La funzione customQuery in movimenticontrollers.js che esegue query SQL grezze inviate dal frontend è una grave vulnerabilità di sicurezza (SQL Injection). Dovrebbe essere rimossa o pesantemente modificata per accettare solo parametri e costruire la query in modo sicuro nel backend. Questo è indipendente dalla questione dell'unificazione dei controller ma è un punto critico.
In conclusione, unificare la logica CRUD comune è vantaggioso per la qualità del codice. Non migliorerà direttamente le performance, ma renderà il tuo backend più pulito, coerente e facile da mantenere.

Context Sources (51)

User
effettia le stesse modifiche anche per dibacontrollers.js, causalicontrollers.js e movimenticontrollers.js


Gemini
Certamente! Applicherò lo stesso pattern di refactoring utilizzando createCrudHandlers anche per dibacontrollers.js e causalicontrollers.js.

Per movimenticontrollers.js, la situazione è un po' diversa a causa della logica di business più complessa (transazioni, aggiornamento delle giacenze) nelle operazioni di inserimento e cancellazione. Pertanto, gli handler CRUD generici non possono sostituire completamente la logica esistente per insertMovimento e deleteMovimento. Tuttavia, possiamo usarli per getMovimentoById e potenzialmente per un getMovimenti di base se non fossero necessari i join di default (ma la tua getMovimenti attuale con i join è più utile). L'operazione updateMovimento è attualmente un placeholder e potrebbe essere sostituita da un handler CRUD generico se si volesse solo un aggiornamento semplice dei campi, ma un vero aggiornamento di un movimento con impatto sulle giacenze richiederebbe una logica personalizzata simile a quella di inserimento/cancellazione.

Ecco le modifiche proposte:

1. Modifiche a causalicontrollers.js
causalicontrollers.js
-67
+24
//@author: "villari.andrea@libero.it"
//@version: "1.0.0 2025-06-12"
//==========================================
const db = require("../db/db"); 
const { createCrudHandlers } = require('./crudHandlers');

(async () => {
  try {
  }
})();

// Funzione di validazione specifica per le causali
function validateCausaleInput(data, operation) {
  const { codice, description, tipo } = data;
  if (!codice || typeof codice !== 'string' || codice.trim() === '') {
    return "Il campo 'codice' è obbligatorio e deve essere una stringa non vuota.";
  }
  if (description === undefined || typeof description !== 'string') { // Permettiamo stringa vuota per description
    return "Il campo 'description' deve essere una stringa.";
  }
  if (!tipo || !['C', 'S', 'N'].includes(tipo.toUpperCase())) { // Esempio: Carico, Scarico, Neutro
    return "Il campo 'tipo' è obbligatorio e deve essere 'C', 'S', o 'N'.";
  }
  return null; // Nessun errore
}

const causaliCrudHandlers = createCrudHandlers('causali', {
  fieldsToSelect: 'id, codice, description, tipo', // Specifica i campi se non vuoi '*'
  validateInput: validateCausaleInput
});

// GET tutte le causali
exports.getCausali = async (req, res) => {
  try {
    const [rows] = await db.query("SELECT * FROM causali ORDER BY codice");
    res.json({ success: true, data: rows });
  } catch (error) {
    console.error("Errore nel recupero delle causali:", error);
    res.status(500).json({ success: false, error: error.message });
  }
};

// POST: nuova causale
exports.insertCausale = async (req, res) => {
  const { codice, description, tipo } = req.body;
  if (!codice || description === undefined || tipo === undefined) {
    return res.status(400).json({ success: false, error: "Dati mancanti o incompleti per la causale." });
  }

  try {
    const [result] = await db.query(
      "INSERT INTO causali (codice, description, tipo) VALUES (?, ?, ?)",
      [codice, description, tipo]
    );
    res.status(201).json({ success: true, id: result.insertId, message: "Causale inserita con successo" });
  } catch (error) {
    console.error("Errore durante l'inserimento della causale:", error);
    res.status(500).json({ success: false, error: error.message });
  }
};

// PUT: modifica causale
exports.updateCausale = async (req, res) => {
  const { id } = req.params;
  const { codice, description, tipo } = req.body;
  if (!codice || description === undefined || tipo === undefined) {
    return res.status(400).json({ success: false, error: "Dati mancanti o incompleti per l'aggiornamento della causale." });
  }
  try {
    const [result] = await db.query(
      "UPDATE causali SET codice=?, description=?, tipo=? WHERE id=?",
      [codice, description, tipo, id]
    );
    if (result.affectedRows === 0) {
      return res.status(404).json({ success: false, error: "Causale non trovata per l'aggiornamento." });
    }
    res.json({ success: true, message: "Causale aggiornata con successo" });
  } catch (error) {
    console.error("Errore durante l'aggiornamento della causale:", error);
    res.status(500).json({ success: false, error: error.message });
  }
};

// DELETE: elimina causale
exports.deleteCausale = async (req, res) => {
  const { id } = req.params;
  try {
    const [result] = await db.query("DELETE FROM causali WHERE id=?", [id]);
    if (result.affectedRows === 0) {
      return res.status(404).json({ success: false, error: "Causale non trovata per l'eliminazione." });
    }
    res.json({ success: true, message: "Causale eliminata con successo" });
  } catch (error) {
    console.error("Errore durante l'eliminazione della causale:", error);
    res.status(500).json({ success: false, error: error.message });
  }
};
exports.getCausali = causaliCrudHandlers.getAll;
exports.getCausaleById = causaliCrudHandlers.getById; // Aggiunto per coerenza
exports.insertCausale = causaliCrudHandlers.create;
exports.updateCausale = causaliCrudHandlers.update;
exports.deleteCausale = causaliCrudHandlers.delete;

2. Modifiche a dibacontrollers.js
Ho rimosso la funzione getMovimenti che era un copia-incolla errato e ho implementato gli handler CRUD per diba. Ho anche corretto un errore di sintassi in updateDiBa.

dibacontrollers.js
-87
+27
//@author: "villari.andrea@libero.it"
//@version: "1.0.0 2025-06-12"
//==========================================
const db = require("../db/db"); 
const { createCrudHandlers } = require('./crudHandlers');

(async () => {
  try {
  }
})();

// GET tutti i movimenti (potresti voler aggiungere filtri, es. per articolo o data)
exports.getMovimenti = async (req, res) => {
// Funzione di validazione specifica per le DiBa
function validateDiBaInput(data, operation) {
  const { codice, description, tipo } = data; // Assumendo questi campi per la tabella 'diba'
  if (!codice || typeof codice !== 'string' || codice.trim() === '') {
    return "Il campo 'codice' è obbligatorio per la DiBa.";
  }
  if (description === undefined || typeof description !== 'string') {
    return "Il campo 'description' deve essere una stringa per la DiBa.";
  }
  if (tipo === undefined || typeof tipo !== 'string' ) { // Adattare i tipi validi se necessario
    return "Il campo 'tipo' è obbligatorio per la DiBa.";
  }
  // Aggiungere altre validazioni se necessario
  return null; // Nessun errore
}

  try {
    // Esempio: potresti voler fare un JOIN per ottenere anche il nome dell'articolo e la descrizione della causale
    
    const [rows] = await db.query(`
      SELECT 
        m.id, 
        m.data, 
        m.quantita, 
        a.name as descriptionart, 
        c.description as descriptioncau,
        m.tipo,
        m.idart,
        m.idcau,
        m.note
      FROM movimenti m
      JOIN articoli a ON m.idart = a.id
      JOIN causali c ON m.idcau = c.id
      ORDER BY m.data DESC
    `);
      //console.log("Query eseguita. Risultati:", rows);
const dibaCrudHandlers = createCrudHandlers('diba', { // Assumendo che la tabella si chiami 'diba'
  fieldsToSelect: 'id, codice, description, tipo', // Adattare i campi se necessario
  validateInput: validateDiBaInput
});

    res.json({ success: true, data: rows });
    //console.log({data: rows});
  } catch (error) {
    console.error("Errore nel recupero dei movimenti:", error);
    res.status(500).json({ success: false, error: error.message });
  }
};
exports.getAllDiBa = dibaCrudHandlers.getAll;
exports.getDiBaById = dibaCrudHandlers.getById;
exports.insertDiBa = dibaCrudHandlers.create;
exports.updateDiBa = dibaCrudHandlers.update;
exports.deleteDiBa = dibaCrudHandlers.delete;


// POST: nuova DiBa
exports.insertDiBa = async (req, res) => {
  const { codice, description, tipo } = req.body;
  if (!codice || description === undefined || tipo === undefined) {
    return res.status(400).json({ success: false, error: "Dati mancanti o incompleti per la DiBa." });
  }

  try {
    const [result] = await db.query(
      "INSERT INTO diba (codice, description, tipo) VALUES (?, ?, ?)",
      [codice, description, tipo]
    );
    res.status(201).json({ success: true, id: result.insertId, message: "DiBa inserita con successo" });
  } catch (error) {
    console.error("Errore durante l'inserimento della Distinta Base:", error);
    res.status(500).json({ success: false, error: error.message });
  }
};

// PUT: modifica DiBa
exports.updateDiBa = async (req, res) => {
  const { id } = req.params;
  const { codice, description, tipo } = req.body;
  if (!codice || description === undefined || tipo === undefined) {
    return res.status(400).json({ success: false, error: "Dati mancanti o incompleti per l'aggiornamento della DiBa." });
  }
  try {
    const [result] = await db.query(
      "UPDATE diba SET codice=?, description=?, tipo=? WHERE id=?",
      [codice, description, tipo, id]
    );
    if (result.affectedRows === 0) {
      return res.status(404).json({ success: false, error: "Distinta Base non trovata per l'aggiornamento." });
    }
    res.json({ success: true, m
      
      } catch (error) {
    console.error("Errore durante l'aggiornamento della Distinta Base:", error);
    res.status(500).json({ success: false, error: error.message });
  }
};

// DELETE: elimina DiBa
exports.deleteDiBa = async (req, res) => {
  const { id } = req.params;
  try {
    const [result] = await db.query("DELETE FROM diba WHERE id=?", [id]);
    if (result.affectedRows === 0) {
      return res.status(404).json({ success: false, error: "Distinta Base non trovata per l'eliminazione." });
    }
    res.json({ success: true, message: "Distinta Base eliminata con successo" });
  } catch (error) {
    console.error("Errore durante l'eliminazione della Distinta Base:", error);
    res.status(500).json({ success: false, error: error.message });
  }
};
// Correzione dell'errore di sintassi in updateDiBa originale, ora gestito da crudHandlers
// L'handler generico gestisce già il messaggio di successo.
3. Modifiche a movimenticontrollers.js
Qui, aggiungo getMovimentoById utilizzando l'handler generico. Le altre funzioni (customQuery, getMovimenti, insertMovimento, updateMovimento, deleteMovimento) rimangono personalizzate a causa della loro logica specifica o dei rischi di sicurezza (nel caso di customQuery).

movimenticontrollers.js
-20
+29
//@author: "villari.andrea@libero.it"
//@version: "1.0.0 2025-06-12"
//==================================================
const db = require("../db/db");
const { createCrudHandlers } = require('./crudHandlers');

const movimentiSpecificFields = 'm.id, m.data, m.quantita, a.name as descriptionart, c.description as descriptioncau, m.tipo, m.idart, m.idcau, m.note';
const movimentiJoins = 'FROM movimenti m JOIN articoli a ON m.idart = a.id JOIN causali c ON m.idcau = c.id';

const movimentoCrudHandlers = createCrudHandlers('movimenti', { fieldsToSelect: movimentiSpecificFields, baseQueryWithJoins: movimentiJoins });

// Query personalizzata per eseguire un filtro dei dati database sulla tabella dataabase
exports.customQuery = async (req, res) => {
  }

  try {
    // ATTENZIONE: Eseguire query SQL grezze dal client è una grave vulnerabilità di sicurezza (SQL Injection).
    const [rows] = await db.query(query);
    res.json({ success: true, data: rows });
  } catch (error) {
}
};

// GET tutti i movimenti (potresti voler aggiungere filtri, es. per articolo o data)
// GET tutti i movimenti con join specifici
exports.getMovimenti = async (req, res) => {

  try {
    // Esempio: potresti voler fare un JOIN per ottenere anche il nome dell'articolo e la descrizione della causale
    
    const [rows] = await db.query(`
      SELECT 
        m.id, 
        m.data, 
        m.quantita, 
        a.name as descriptionart, 
        c.description as descriptioncau,
        m.tipo,
        m.idart,
        m.idcau,
        m.note
      FROM movimenti m
      JOIN articoli a ON m.idart = a.id
      JOIN causali c ON m.idcau = c.id
      SELECT ${movimentiSpecificFields}
      ${movimentiJoins}
      ORDER BY m.data DESC
    `);
      //console.log("Query eseguita. Risultati:", rows);

    res.json({ success: true, data: rows });
    //console.log({data: rows});
  } catch (error) {
    console.error("Errore nel recupero dei movimenti:", error);
    res.status(500).json({ success: false, error: error.message });
  }
};

// GET singolo movimento by ID con join specifici
exports.getMovimentoById = async (req, res) => {
  const { id } = req.params;
  try {
    const [rows] = await db.query(`
      SELECT ${movimentiSpecificFields}
      ${movimentiJoins}
      WHERE m.id = ?
    `, [id]);
    if (rows.length === 0) {
      return res.status(404).json({ success: false, error: "Movimento not found." });
    }
    res.json({ success: true, data: rows[0] });
  } catch (error) {
    console.error(`Error fetching movimento by ID ${id}:`, error);
    res.status(500).json({ success: false, error: error.message });
  }
+};
+
 // POST: nuovo movimento
 exports.insertMovimento = async (req, res) => {
   // Esempio di campi per un movimento. Adattali!

Per movimenticontrollers.js, ho aggiunto getMovimentoById che utilizza una query simile a getMovimenti per includere i join necessari. Le funzioni insertMovimento, updateMovimento (che è un placeholder e andrebbe implementata con logica di business se dovesse aggiornare più delle note o impattare le giacenze), e deleteMovimento rimangono personalizzate a causa della loro complessità e della gestione delle transazioni e delle giacenze. La funzione customQuery rimane anch'essa separata, ma ti ricordo che è una grave vulnerabilità di sicurezza e andrebbe gestita con estrema cautela o, preferibilmente, sostituita con un approccio più sicuro che non esegua query SQL grezze provenienti dal client.

Queste modifiche dovrebbero aiutarti a ridurre la duplicazione del codice per le operazioni CRUD standard, mantenendo la logica specifica dove necessario.

Context Sources (51)
